<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ album.album_name }} - {{ album.artist_name }} Ranking</title>
    <style>
        /* Base styles */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header section */
        header {
            display: flex;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        header img {
            height: 120px;
            width: 120px;
            object-fit: cover;
            border-radius: 8px;
            margin-right: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        header .album-info h1 {
            margin: 0 0 5px 0;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
        }

        header .album-info h2 {
            margin: 0;
            font-size: 20px;
            font-weight: normal;
            color: #bbb;
        }

        /* Main content container */
        #container {
            display: flex;
            flex: 1; /* Allow container to fill available height */
            gap: 20px;
            padding: 20px;
        }

        /* Left panel: song list */
        #songListContainer {
            flex: 1;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            position: relative; /* For scrollbar styling */
        }

        #songListContainer h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        #songList {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .song-item {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #333 0%, #444 100%);
            margin: 8px 0;
            padding: 12px;
            border-radius: 8px;
            cursor: grab;
            transition: all 0.2s ease;
            border-left: 4px solid transparent;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .song-item:hover {
            background: linear-gradient(135deg, #444 0%, #555 100%);
            transform: translateX(4px);
        }

        .song-item.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
        }

        .song-item.ranked {
            border-left-color: #4CAF50; /* Green checkmark indicator */
            cursor: default;
            opacity: 0.7;
            filter: grayscale(20%);
        }
        .song-item.ranked .prelim-rank-input {
            pointer-events: none;
            opacity: 0.7;
            background: #555; /* Darker background for disabled input */
        }

        .song-name {
            flex: 1;
            font-weight: 500;
        }
        .ranked-group-display {
            margin-left: 8px; /* Space between checkmark and rank group */
            font-size: 14px; /* Adjust size as needed */
            font-weight: bold;
            color: #FFD700; /* A gold-like color for visibility */
            display: none; /* Hidden by default, JavaScript will make it 'inline-block' when needed */
}

        .prelim-rank-input {
            width: 60px;
            margin: 0 10px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .prelim-rank-input:focus {
            border-color: #4CAF50;
            outline: none;
        }

        .checkmark {
            color: #4CAF50;
            font-size: 18px;
            font-weight: bold;
            margin-left: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .song-item.ranked .checkmark {
            opacity: 1;
        }

        /* Right panel: ranking interface */
        #rankContainer {
            flex: 1.5;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        #rankContainer h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        #rankButtons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }

        .rank-button {
            padding: 10px 8px;
            background: linear-gradient(135deg, #555 0%, #666 100%);
            color: #ddd;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-button:hover {
            background: linear-gradient(135deg, #666 0%, #777 100%);
            transform: translateY(-2px);
        }

        .rank-button.active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            font-weight: bold;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        /* Icon for rank buttons indicating content */
        .rank-button-icon {
            margin-left: 5px;
            font-size: 0.8em;
            color: #ccc;
            visibility: hidden;
        }

        .rank-button.has-songs .rank-button-icon {
            visibility: visible;
            color: #000; /* Darker star for active button content indicator */
        }

        .rank-button.has-songs .rank-button-icon::before {
            content: "★";
        }

        /* Main display area for the currently active rank group */
        #activeRankGroupDisplay {
            flex: 1; /* Take remaining space */
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
            border: 2px dashed #555; /* Indicates it's a drop zone */
            transition: border-color 0.3s ease, background 0.3s ease;
            display: flex;
            justify-content: flex-start;
            flex-direction: column;
        }

        #activeRankGroupDisplay.drag-over {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        /* Container for the actual list of songs within the active group */
        #currentRankGroupContent {
            width: 100%;
            display: flex;
            justify-content: center; /* Center the list within its parent */
        }

        #rankedSongsList {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%; /* Take full width of its container */
            min-height: 50px; /* Give it some height for dragging into */
            /* If you want a visual drop indicator border on the list itself */
            /* border: 1px dashed rgba(255,255,255,0.3); */
            /* border-radius: 5px; */
        }

        .empty-state {
            text-align: center;
            color: #888;
            font-style: italic;
            margin: auto; /* Centers itself in the flex container */
            padding: 20px;
            display: block; /* Shown by default until JS hides it or loads songs */
        }

        .ranked-song {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            color: white;
            font-weight: 500;
            position: relative;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .ranked-song:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .ranked-song.dragging {
            opacity: 0.7;
            transform: rotate(3deg);
        }

        .ranked-song.drag-over { /* For visual insertion point */
            border-top: 2px solid #FFD700;
            margin-top: 20px; /* Create space for the indicator */
        }
        .ranked-song.drag-over:first-child {
            border-top: 2px solid #FFD700;
        }

        .position-indicator {
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            background: #FFD700;
            color: #000;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .score-preview {
            font-size: 12px;
            color: #FFD700;
            margin-left: auto; /* Push to the right */
            font-weight: normal;
        }

        /* Footer buttons */
        #actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 15px;
        }

        .action-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        #pauseSaveBtn {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }

        #pauseSaveBtn:hover {
            background: linear: gradient(135deg, #FFB74D 0%, #FF9800 100%);
            transform: translateY(-2px);
        }

        #finalRankBtn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        #finalRankBtn:hover {
            background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 100%);
            transform: translateY(-2px);
        }

        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <header>
        <img src="{{ album.album_cover_url }}" alt="Album Cover">
        <div class="album-info">
            <h1>{{ album.album_name }}</h1>
            <h2>{{ album.artist_name }}</h2>
        </div>
    </header>

    <form id="rankingForm" action="/submit_rankings" method="POST">
        <input type="hidden" id="album_id" name="album_id" value="{{ album.album_id }}">
        <input type="hidden" id="album_name" name="album_name" value="{{ album.album_name }}">
        <input type="hidden" id="artist_name" name="artist_name" value="{{ album.artist_name }}">
        <input type="hidden" id="album_cover_url" name="album_cover_url" value="{{ album.album_cover_url }}">

        <input type="hidden" name="all_ranked_data" id="all_ranked_data">
        <input type="hidden" name="prelim_rank_data" id="prelim_rank_data">
        <input type="hidden" name="status" id="status_input"> <div id="container">
            <div id="songListContainer">
                <h3>Songs</h3>
                <ul id="songList">
                    {% for song in album.songs %}
                    <li class="song-item {% if song.get('already_ranked') %}ranked{% endif %}"
                        draggable="true"
                        data-song="{{ song.song_name }}"
                        data-song-id="{{ song.song_id }}">
                        <span class="song-name">{{ song.song_name }}</span>
                        <input type="number"
                               class="prelim-rank-input"
                               min="0.5"
                               max="10"
                               step="0.5"
                               name="prelim_rank_{{ song.song_id }}"
                               value="{{ song.get('prelim_rank', '') }}"
                               placeholder="0.5-10"
                               title="Preliminary rank (0.5-10)">
                        <span class="checkmark">✓</span>
                        <span class="ranked-group-display"></span>
                    </li>
                    {% endfor %}
                </ul>
            </div>

            <div id="rankContainer">
                <h3>Rank Groups</h3>
                <div id="rankButtons">
                    {% for i in range(1, 21) %}
                        {% set rank = (i * 0.5)|round(1) %}
                        <button type="button" class="rank-button" data-rank="{{ rank }}" id="rank-btn-{{ rank }}">
                            {{ rank }}
                            <span class="rank-button-icon"></span>
                        </button>
                    {% endfor %}
                </div>

                <div id="activeRankGroupDisplay">
                    <div class="empty-state" id="emptyState">
                        Select a rank group above to start ranking songs.
                    </div>
                    <div id="currentRankGroupContent">
                        <ul id="rankedSongsList">
                        </ul>
                    </div>
                </div>

                <div id="actions">
                    <button type="button" class="action-button" id="finalRankBtn">Final Rank</button>
                </div>
            </div> {# closes #rankContainer #}
        </div> {# closes #container #}
    </form> {# closes #rankingForm #}

    <script>
    let draggingSong = null;
    let currentRankGroup = null; // Stores the currently selected rank (e.g., "4.5", "5.0", "?")

    // Global data structure to hold all ranked songs, organized by group
    let allRankedSongsByGroup = {};

    // On page load, initialize allRankedSongsByGroup with data from Flask
    const initialRankGroups = {{ rank_groups | tojson }};
    console.log("Initial rank groups from Flask:", initialRankGroups);

    // Initialize all possible rank groups and populate them from initialRankGroups
    for (let i = 1; i <= 20; i++) {
        const rank = (i * 0.5).toFixed(1);
        allRankedSongsByGroup[rank] = initialRankGroups[rank] || [];
    }
    // Corrected this line as the '?' group is no longer used in the buttons
    // If you need to initialize it for existing data, you can keep it, but it won't be activated by buttons.
    // allRankedSongsByGroup['?'] = initialRankGroups['?'] || [];

    // Add event listeners to rank buttons
    document.querySelectorAll('.rank-button').forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            document.querySelectorAll('.rank-button').forEach(btn => btn.classList.remove('active'));
            // Add active class to the clicked button
            this.classList.add('active');

            currentRankGroup = this.dataset.rank;
            console.log("Selected rank group:", currentRankGroup);
            loadRankedSongsIntoDisplay(currentRankGroup);
        });
    });

    // Helper to check if a song (by ID) is ranked in *any* group
    function getSongRankGroup(songId) {
        for (const group in allRankedSongsByGroup) {
            // Exclude '?' from this check as it's not a final ranking destination
            if (group !== '?' && Array.isArray(allRankedSongsByGroup[group]) &&
                allRankedSongsByGroup[group].some(s => s.song_id === songId)) {
                return group; // Returns the group string, e.g., "7.0"
            }
        }
        return null; // Song not found in any ranked group
    }

    // Function to update the icon of a RANK BUTTON based on its group's content
    function updateRankButtonIcon(rankGroupKey) {
        // Removed 'rank-btn-question' as it's no longer used.
        const rankButton = document.getElementById(`rank-btn-${rankGroupKey}`);
        if (!rankButton) return;

        const songsInGroup = allRankedSongsByGroup[rankGroupKey] || [];

        if (songsInGroup.length > 0) {
            rankButton.classList.add('has-songs');
        } else {
            rankButton.classList.remove('has-songs');
        }
    }

    // Function to update icons for ALL rank buttons
    function updateAllRankButtonIcons() {
        for (let i = 1; i <= 20; i++) {
            updateRankButtonIcon((i * 0.5).toFixed(1));
        }
        // Removed `updateRankButtonIcon('?');` as the '?' button is no longer explicitly managed/used
    }

    // This function now *displays* songs from the global data structure
    function loadRankedSongsIntoDisplay(rank) {
        const rankedSongsListDisplay = document.getElementById('rankedSongsList');
        const emptyState = document.getElementById('emptyState');
        rankedSongsListDisplay.innerHTML = ''; // Clear current display

        const songsToDisplay = allRankedSongsByGroup[rank] || [];
        console.log(`Displaying ${songsToDisplay.length} songs for rank group: ${rank}`);

        if (songsToDisplay.length === 0) {
             emptyState.style.display = 'block'; // Show empty state if no songs
             emptyState.textContent = `Drag songs here to rank them in the ${rank} group.`;
             rankedSongsListDisplay.style.display = 'none'; // Hide the ul if empty
        } else {
             emptyState.style.display = 'none';
             rankedSongsListDisplay.style.display = 'block'; // Show the ul if songs are present
        }

        songsToDisplay.forEach((song, index) => {
            const li = createRankedSongElement(song, index, songsToDisplay.length, rank);
            rankedSongsListDisplay.appendChild(li);
        });

        updateSongCheckmarks(); // Update checkmarks on the left panel
    }

    // Helper to create a ranked song <li> element
    function createRankedSongElement(songData, index, totalSongsInGroup, currentRankGroupKey) {
        const li = document.createElement('li');
        li.className = 'ranked-song';
        li.setAttribute('draggable', 'true');
        li.dataset.song = songData.song_name;
        li.dataset.songId = songData.song_id;
        li.dataset.rankGroup = currentRankGroupKey; // This should reflect the group it's currently displayed in
        li.dataset.rankPosition = index; // Store 0-based index for display ordering

        const positionIndicator = document.createElement('span');
        positionIndicator.className = 'position-indicator';
        positionIndicator.textContent = index + 1; // 1-based index

        li.appendChild(positionIndicator);
        li.appendChild(document.createTextNode(songData.song_name));

        const scorePreview = document.createElement('span');
        scorePreview.className = 'score-preview';
        scorePreview.textContent = calculateScore(index, totalSongsInGroup, parseFloat(currentRankGroupKey));
        li.appendChild(scorePreview);

        return li;
    }

    function calculateScoreValue(position, totalSongs, rankGroup) {
        if (totalSongs === 0) return 0;
        if (totalSongs === 1) return rankGroup;

        const range = 0.49; // This defines the score range within a group (e.g., for a 5.0 group, scores can be 5.0 to 5.49)
        const effectiveTotalSongs = Math.max(1, totalSongs); // Ensure no division by zero if totalSongs is 0
        const step = range / effectiveTotalSongs;
        const highestScore = parseFloat(rankGroup) + range;
        const score = highestScore - (step * position);

        return parseFloat(score.toFixed(2)); // Return as a number, rounded to 2 decimal places
    }

    // Modify your existing calculateScore to use this for display:
    function calculateScore(position, totalSongs, rankGroup) {
        const score = calculateScoreValue(position, totalSongs, rankGroup);
        return `(${score.toFixed(2)})`; // Return as a formatted string for display
    }

    // Update checkmarks and drag-ability for songs in the left panel
    function updateSongCheckmarks() {
        document.querySelectorAll('.song-item').forEach(item => {
            const songId = item.dataset.songId;
            const rankGroupDisplay = item.querySelector('.ranked-group-display'); // Get the new span

            const rankedGroup = getSongRankGroup(songId); // Check if song is ranked and get its group

            if (rankedGroup) { // If the song is found in a ranked group
                item.classList.add('ranked');
                item.setAttribute('draggable', 'false');
                const prelimInput = item.querySelector('.prelim-rank-input');
                if (prelimInput) {
                    prelimInput.disabled = true;
                }

                // Display the rank group number
                if (rankGroupDisplay) {
                    rankGroupDisplay.textContent = rankedGroup; // Set the text (e.g., "7.0")
                    rankGroupDisplay.style.display = 'inline-block'; // Make it visible
                }

            } else { // Song is NOT ranked (either unranked or dropped back to unranked list)
                item.classList.remove('ranked');
                item.setAttribute('draggable', 'true');
                const prelimInput = item.querySelector('.prelim-rank-input');
                if (prelimInput) {
                    prelimInput.disabled = false;
                }
                // Hide the rank group number if the song is unranked
                if (rankGroupDisplay) {
                    rankGroupDisplay.textContent = ''; // Clear text
                    rankGroupDisplay.style.display = 'none'; // Hide it
                }
            }
        });
    }

    // --- Drag and drop functionality ---
    document.addEventListener('dragstart', function(e) {
        if (e.target.classList.contains('song-item') || e.target.classList.contains('ranked-song')) {
            draggingSong = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.setData("text/plain", e.target.dataset.songId); // Pass song ID
            e.dataTransfer.effectAllowed = "move"; // Indicate move operation

            // If dragging from a ranked group, remember its original group for removal later
            if (e.target.classList.contains('ranked-song')) {
                e.dataTransfer.setData("text/original-rank-group", e.target.dataset.rankGroup);
                e.dataTransfer.setData("text/original-rank-position", e.target.dataset.rankPosition);
            } else { // Dragging from the left song list (potentially with a prelim rank)
                 const prelimInput = e.target.querySelector('.prelim-rank-input');
                 if (prelimInput) {
                     e.dataTransfer.setData("text/prelim-rank", prelimInput.value || "");
                 }
            }
        } else {
            e.preventDefault(); // Prevent dragging non-song elements
        }
    });

    const activeRankGroupDisplay = document.getElementById('activeRankGroupDisplay');

    activeRankGroupDisplay.addEventListener('dragover', function(e) {
        e.preventDefault(); // Allow drop
        e.dataTransfer.dropEffect = "move";
        this.classList.add('drag-over');

        // Visual insertion point logic
        const targetElement = e.target.closest('.ranked-song');
        const rankedSongsList = document.getElementById('rankedSongsList');
        const children = Array.from(rankedSongsList.children).filter(child => !child.classList.contains('dragging'));

        // Remove all existing drag-over indicators
        children.forEach(child => child.classList.remove('drag-over'));

        if (targetElement && targetElement.classList.contains('ranked-song') && !targetElement.classList.contains('dragging')) {
            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.y + rect.height / 2;

            if (e.clientY < midpoint) {
                targetElement.classList.add('drag-over-top');
            } else {
                targetElement.classList.add('drag-over-bottom');
            }
        } else if (children.length === 0 && e.target === rankedSongsList) {
            // Special case for an empty list, just indicate the list itself is droppable
            rankedSongsList.classList.add('drag-over');
        }
    });

    activeRankGroupDisplay.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
        document.querySelectorAll('.ranked-song').forEach(song => {
            song.classList.remove('drag-over-top', 'drag-over-bottom');
        });
    });


    activeRankGroupDisplay.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        document.querySelectorAll('.ranked-song').forEach(song => {
            song.classList.remove('drag-over-top', 'drag-over-bottom');
        });

        if (!draggingSong || !currentRankGroup) {
            return; // No song being dragged or no rank group selected
        }

        const songId = e.dataTransfer.getData("text/plain");
        const originalRankGroup = e.dataTransfer.getData("text/original-rank-group");
        const originalRankPosition = e.dataTransfer.getData("text/original-rank-position");
        const prelimRank = e.dataTransfer.getData("text/prelim-rank"); // Get prelim rank if available

        let songDataToMove;

        // 1. Remove from original group (if it was already ranked)
        if (originalRankGroup && allRankedSongsByGroup[originalRankGroup]) {
            const originalIndex = parseInt(originalRankPosition, 10);
            if (originalIndex >= 0 && originalIndex < allRankedSongsByGroup[originalRankGroup].length) {
                // Get the song data before splicing it out
                songDataToMove = allRankedSongsByGroup[originalRankGroup].splice(originalIndex, 1)[0];
            }
        }

        // 2. If it wasn't from a ranked group, find it in the songList (left panel)
        if (!songDataToMove) {
            const songItemElement = document.querySelector(`.song-item[data-song-id="${songId}"]`);
            if (songItemElement) {
                songDataToMove = {
                    song_id: songId,
                    song_name: songItemElement.dataset.song,
                    // Pass prelim_rank if it exists
                    prelim_rank: prelimRank ? parseFloat(prelimRank) : undefined
                };
            }
        }

        if (!songDataToMove) {
            console.error("Could not find song data to move for ID:", songId);
            return;
        }

        // Calculate score for the song *as it's being added* to the new group
        // This score is temporary and will be recalculated on final submission
        // (but good for showing immediate visual feedback)
        const targetElement = e.target.closest('.ranked-song');
        let newIndex = 0; // Default to top if no specific target or empty list

        if (targetElement && targetElement.classList.contains('ranked-song')) {
            const targetIndex = parseInt(targetElement.dataset.rankPosition, 10);
            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.y + rect.height / 2;

            if (e.clientY < midpoint) {
                newIndex = targetIndex; // Insert before target
            } else {
                newIndex = targetIndex + 1; // Insert after target
            }
        } else {
            // Dropped into an empty list or not on a specific song element
            newIndex = (allRankedSongsByGroup[currentRankGroup] || []).length;
        }

        // Ensure the array exists for the current group
        if (!allRankedSongsByGroup[currentRankGroup]) {
            allRankedSongsByGroup[currentRankGroup] = [];
        }

        // Assign the calculated score *to the songDataToMove object*
        // This is the point where 'calculated_score' should be set on the JS object
        songDataToMove.calculated_score = calculateScoreValue(newIndex, allRankedSongsByGroup[currentRankGroup].length + 1, parseFloat(currentRankGroup));
        console.log(`Calculated score for ${songDataToMove.song_name}: ${songDataToMove.calculated_score}`);


        // 3. Add to new group at the calculated index
        allRankedSongsByGroup[currentRankGroup].splice(newIndex, 0, songDataToMove);

        // Re-render the current rank group's songs
        loadRankedSongsIntoDisplay(currentRankGroup);
        // Update all rank button icons (to show if groups now have songs)
        updateAllRankButtonIcons();
        // Update checkmarks on the left panel
        updateSongCheckmarks();

        draggingSong = null; // Reset dragging state
    });

    // Handle dropping songs back to the unranked list (left panel)
    const songListContainer = document.getElementById('songListContainer');

    songListContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        this.classList.add('drag-over-unranked'); // Add a visual indicator
    });

    songListContainer.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over-unranked');
    });

    songListContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over-unranked');

        if (!draggingSong) {
            return;
        }

        const songId = e.dataTransfer.getData("text/plain");
        const originalRankGroup = e.dataTransfer.getData("text/original-rank-group");
        const originalRankPosition = e.dataTransfer.getData("text/original-rank-position");
        const prelimRank = e.dataTransfer.getData("text/prelim-rank"); // Get prelim rank if available

        if (originalRankGroup && allRankedSongsByGroup[originalRankGroup]) {
            const originalIndex = parseInt(originalRankPosition, 10);
            if (originalIndex >= 0 && originalIndex < allRankedSongsByGroup[originalRankGroup].length) {
                // Get the song data before splicing it out
                const songDataToMove = allRankedSongsByGroup[originalRankGroup].splice(originalIndex, 1)[0];
                // Remove calculated_score if you want it to truly be "unranked"
                delete songDataToMove.calculated_score;
                // Preserve prelim_rank if it came with one
                if (prelimRank) {
                    songDataToMove.prelim_rank = parseFloat(prelimRank);
                } else {
                    delete songDataToMove.prelim_rank; // Clear prelim if none was there
                }
            }

            // Re-render the original group if it was the currently active one
            if (currentRankGroup === originalRankGroup) {
                loadRankedSongsIntoDisplay(originalRankGroup);
            }
            // Update all rank button icons
            updateAllRankButtonIcons();
            // Update checkmarks on the left panel (this will re-enable drag for this song)
            updateSongCheckmarks();
        }
        draggingSong = null; // Reset dragging state
    });

    // --- Save/Submit functionality ---
// Assuming you have ONE "Final Rank" button with id="finalRankBtn" in your HTML,
// and it calls saveRankings()
    document.getElementById('finalRankBtn').addEventListener('click', function() {
        saveRankings();
    });

    function saveRankings() {
        const allRankedData = [];
        // Iterate through all numeric rank groups and collect song data
        for (const rankGroup in allRankedSongsByGroup) {
            // Exclude the '?' group as it's no longer a valid ranking group for submission.
            // We only care about songs explicitly placed in numeric rank groups.
            if (rankGroup !== '?' && Array.isArray(allRankedSongsByGroup[rankGroup])) {
                allRankedSongsByGroup[rankGroup].forEach((song, index) => {
                    // IMPORTANT: Ensure song.calculated_score is populated BEFORE this point.
                    // This happens in your drag-and-drop `drop` event listener when the song object
                    // is first added to allRankedSongsByGroup.
                    if (typeof song.calculated_score === 'undefined' || song.calculated_score === null) {
                        console.error(`ERROR: song.calculated_score is missing for song ID: ${song.song_id}. This will cause backend errors.`);
                        // As a fallback, try to calculate it here if it's missing (though better to fix at source)
                        const tempTotalSongs = allRankedSongsByGroup[rankGroup].length;
                        song.calculated_score = calculateScoreValue(index, tempTotalSongs, parseFloat(rankGroup));
                    }

                    allRankedData.push({
                        song_id: song.song_id,
                        song_name: song.song_name,
                        rank_group: rankGroup, // Stored as a string like "5.0"
                        rank_position: index + 1, // 1-based index within group
                        calculated_score: song.calculated_score,
                        // Pass prelim_rank if it exists on the song object.
                        // This will be for songs that were prelim-ranked, then dragged into a final group.
                        prelim_rank: song.prelim_rank || "" // Ensure it's not undefined
                    });
                });
            }
        }

        const prelimRankData = {};
        // Collect preliminary ranks from the left song list (only unranked ones)
        document.querySelectorAll('.song-item').forEach(item => {
            const songId = item.dataset.songId;
            const prelimInput = item.querySelector('.prelim-rank-input');

            // Check if the song exists in *any* of the `allRankedData` (numeric ranked songs)
            const isSongInRankedGroup = allRankedData.some(s => s.song_id === songId);

            // If the song is NOT in a final/numeric group AND has a non-empty preliminary input value
            if (!isSongInRankedGroup && prelimInput && prelimInput.value.trim() !== '') {
                const parsedValue = parseFloat(prelimInput.value);
                if (!isNaN(parsedValue)) {
                    prelimRankData[songId] = parsedValue;
                } else {
                    console.warn(`Invalid preliminary rank for song ${songId}: ${prelimInput.value}`);
                }
            }
        });

        let submissionStatus;

        if (allRankedData.length > 0) {
            submissionStatus = 'final'; // User has dragged songs to numeric groups
        } else if (Object.keys(prelimRankData).length > 0) {
            submissionStatus = 'preliminary'; // No final ranks, but preliminary ranks exist
        } else {
            // If neither final nor preliminary ranks are set, we still submit as 'final'.
            // This ensures that any *previously existing* final/preliminary ranks for this
            // album are effectively cleared on the backend, representing a blank state.
            submissionStatus = 'final';
        }

        // Hidden inputs
        document.getElementById('all_ranked_data').value = JSON.stringify(allRankedData);
        document.getElementById('prelim_rank_data').value = JSON.stringify(prelimRankData);
        // CRITICAL FIX: Use the dynamically determined submissionStatus
        document.getElementById('status_input').value = submissionStatus;

        console.log("Submitting with all_ranked_data:", allRankedData);
        console.log("Submitting with prelim_rank_data:", prelimRankData);
        console.log("Submitting with status:", document.getElementById('status_input').value);

        // Finally, submit the form
        document.getElementById('rankingForm').submit();
    }

    // Initial render and update of button icons on page load
    document.addEventListener('DOMContentLoaded', () => {
        updateAllRankButtonIcons();

        // Check if any *numeric* rank groups have songs.
        // Iterate through 0.5 to 10.0 to find if any of those groups contain songs.
        let foundInitialActiveGroup = false;
        for (let i = 1; i <= 20; i++) {
            const rank = (i * 0.5).toFixed(1);
            if (allRankedSongsByGroup[rank] && allRankedSongsByGroup[rank].length > 0) {
                const activeButton = document.getElementById(`rank-btn-${rank}`);
                if (activeButton) {
                    activeButton.click(); // This will activate the group and load its songs
                    foundInitialActiveGroup = true;
                    break; // Activate only the first group found with songs
                }
            }
        }

        // If no numeric groups had songs, just ensure the empty state is visible
        if (!foundInitialActiveGroup) {
            document.getElementById('emptyState').style.display = 'block';
            document.getElementById('emptyState').textContent = `Select a rank group above to start ranking songs.`;
            document.getElementById('rankedSongsList').style.display = 'none'; // Hide the ul
        }
    });

    </script>
</body>
</html>